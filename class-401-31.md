# Class 34 Reading Notes: API Integration

**How do bearer tokens work?**

An authentication server creates a token for you after a succesful login and a user client is authenticated. The token is now able to be used by the user client to get access to a resource.

**Describe express middleware**

express middleware are basic functions that can be called to function based on request and response objects.

**What is a JWT?**

JSON Web Token - a method of transmitting secure information as JSON objects.

Can be encrypted, but more likely to be signed which is for verifying integrity rather than secrecy.

## Document the following Vocabulary Terms

- role based access control: Changing access granularly by giving particular access to users.

- http cookies: A piece of data a server places in a client's browser for the use of remembering stateful information.

# Implementation: Graphs

Summary: A non-linear data structure that can be looked as a collection of nodes connected by edges.

**Common Terminology**

- Vertex - Basically a node with zero or more node attached to it.
- Edge - Link between nodes.
- Neighbor - The node adjacent.
- Degree - How many edges are stuck to a node.

## Directed vs Undirected

**Undirected** Does not move in any specified direction. Each edge (link) is bi-directional.

Sort of like a regular traffic intersection.

**Directed** Every edge is directed, each link only connects to another specific node.

Sort of like downtown Seattle with all its one way streets.

## Complete vs Connected vs Disconnected

The types of graphs.

- Complete Graphs: All nodes are connected to all other nodes. Sort of like a peer to peer internet?

- Connected: All nodes have at least one connection. This may be like your laptop connecting to a router node, which then connects to the internet.

- Disconnected: Some of the nodes don't have any connections. This is like when your wifi dies and you have to play that dinosaur jumping game in Chrome.

## Acyclic vs Cyclic

Cycles are when you can traverse nodes and potentially go back to the same node. 

**Cyclic** 

A graph with cycles Like the board game, Monopoly, which goes in a cycle.

**Acyclic**

Directed graph, no cycles. Like the board game, Life which goes in one direction.


## Graph Representation

Graphs are represented through adjacency matrixes or adjacency lists.

**Adjacency Matrix**

A 2-dimensional array. Can look like a chessboard, but with 1s and 0s.

The cross section lets you figure out what is connected to what using the nodes as coordinates, and 1s as confirmed links. e.g. if A and C's intersection has 1, they are connected.

No connection? 0.

**Sparse vs Dense**

A graph is sparse if there are few connections, and dense if there are many. Think of it like, mosquito net vs fishing net.

**Adjacency List**

A more common method of showing graphs, with a node showing its connection to other nodes.

```
A -> C -> D // A is connected to C and D

B -> C -> F // B is connected to C and F

C -> A -> B -> E // C is connected to A, B, and E.

```

## Weighted Graphs

A graph with numbers assigned to the edges. Numbers are weights.

When using a matrix the numbers (weights) are used instead of just 1s.

Adjacency lists just link the weights to the node.

```
A -> B,4 -> D,9 -> C,3 // A is connected to B with weight 4, D with weight 9, and C with weight 3.
```

## Traversals

Graphs must be traversed, very similarly to trees.

**Breadth First**

Start at a specific node, which is called when using ``breadthFirst()``.

In order to prevent infinite loops, you have to keep track of the nodes visited.

Breadth First means checking the nodes closest to the specified node first and going outwards, level by level.

**BF Algo:**

1. `Enqueue` start node into a Queue.
2. Loop as long as nodes exist.
3. `Dequeue` the initial node.
4. If the `DQ'd` node has any unvisited nodes, add the unvisited to the `visited` tracker.


```js
ALGORITHM BreadthFirst(vertex)
    DECLARE nodes <-- new List()
    DECLARE breadth <-- new Queue()
    DECLARE visited <-- new Set()

    breadth.Enqueue(vertex)
    visited.Add(vertex)

    while (breadth is not empty)
        DECLARE front <-- breadth.Dequeue()
        nodes.Add(front)

        for each child in front.Children
            if(child is not visited)
                visited.Add(child)
                breadth.Enqueue(child)   

    return nodes;
```

**Depth First**

Uses a Stack.

**DF Algo**

1. `Push` specified node into the stack.
2. Loop while stack is not empty.
3. `Peek` at top of node in stack.
4. If top node has unvisited child nodes, mark top as visited, then `Push` unvisited child nodes into stack.
5. Once top node doesn't have an unvisited child nodes, `Pop` the top node off.
6. Repeat until stack is empty.

## Real World Uses of Graphs

- GPS/Mapping
- Driving directions
- Social networks
- Airline traffic




## Reading Credit

https://stackoverflow.com/questions/25838183/what-is-the-oauth-2-0-bearer-token-exactly

https://expressjs.com/en/guide/using-middleware.html

https://jwt.io/introduction

https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies