## Class 08 Reading: Access Control

**When is Basic Authorization used vs. Bearer Authorization?** https://stackoverflow.com/questions/34013299/web-api-authentication-basic-vs-bearer

Basic uses authentication using a username and secret.

Bearer uses a token (like OAuth).

**What does the JSON Web Token package do?** https://www.akana.com/blog/what-is-jwt

A method for securing APIs by sharing security info with encoded JSON objects signed with a crypto algorithm.

**What considerations should we make when creating and storing a SECRET?** https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/

It must not be shared. Good idea to be 256 bits generated by a cryptographically secure library, converted to hexadecimal. Never include it in public clients. Never stored in plain text.

- *encryption*: Encoding or hiding information, which can be de-encrypted back through use of a key or algorithm.
- *token*: The thing that applications use to make API requests for the user: https://www.oauth.com/oauth2-servers/access-tokens/
- *bearer*: The possessor of the token.
- *secret*: The secret code that acts as the password for the application.
- *JSON Web Token*: A standard for data with signatures and encryption for their payloads. https://en.wikipedia.org/wiki/JSON_Web_Token

## Class 08 Live Notes: Authorization

Where we've been
    - Basic and Bearer Authentication
        - Who are you?
        - Basic = strings
        - Bearer = token

Today we still need our basic and bearer to work together.
    - How can we tell a user whether or not they are permitted
    - Authorization: Are you allowed?
    - Encode some stuff into our token
    - Create a system (our own home grown) - Access control list.
        - What role does a user have?
        - What capabilities are assigned to a given role?
    - Only helpful *after* we have authenticated
    - Has to occur after authenticated

### Access Control Lists

Each user on our system currently has:

- username
- password
- token
- role: for your system, how many types are req

    - Admins can do anything
    - default users: can only do 1 or a few things
    - editors: can update but not create
    - writers: can create but not update

- Each role maps to a list of capabilities.
    - User [read]
    - Admin [create, read, update, delete]
    - Editor [read, update]
    - Writer [read, create]

### Demo

#### userSchema.js

```js

'use strict';

const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const APP_SECRET = process.env.SECRET || 'secretsting';

const UserSchema = (sequelize, DataTypes) => {
    
    let model = sequelize.define('User', {
        username: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        password: {
            type: DataTypes.STRING,
            allowNull: false,
        },
        role: {
            type: DataTypes.ENUM('user', 'admin', 'editor', 'writer'),
            allowNull: false,
            defaultValue: 'user',
        },
        token:{
            type: DataTypes.VIRTUAL,
            get() {
                return jwt.sign({ username: this.username}, APP_SECRET)
            },
        },
    });

model.beforeCreate = (async (user) => {
    user.password = await bcrypt.hash(user.password, 10);
});

model.authenticateBasic = async function (username, password) {

    try {
        let user = await.thisfindOne({where: {username}});
        let validPassword = await bcrypt.compare(password, user.password);

        if (validPassword){
            return user;
        } else {
            throw new Error('Invalid username or password.');
        }
    } catch (e) {
        console.log(e);
        throw new Error('Error validating user.');
    }       
};

model.authenticateBearer = async function (token) {
    try {
     let validToken = jwt.verify(token, APP_SECRET);
     let user = this.findOne({where: {username: validToken.username}});
        if (user){
            return user;
        } else {
            throw new Error('Invalid token.');
        }


    } catch (e) {
        console.log(e);
        throw new Error('Invalid credentials.');
    }       

};

return model;
};

```

#### basic-auth.js

```js

```

#### bearer-auth.js

```js

// curried function = a function that returns another function

```

#### access-controljs

```js

'use strict';

module.exports = (calability) => (req, res, next) => {
    const acl = {
        'user': ['read'],
        'editor': ['read', 'update'],
        'writer': ['read', 'create'],
        'admin': ['read', 'create', 'update', 'delete'],
    };

    if (acl[req.user.role].includes(capability)) {
        next();
    } else {
        next('Unauthorized.');
    }


    };

```

#### server.js

```js

'use strict';

const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const { Sequelize, DataTypes } = require('sequelize');
const userSchema = require('./model/userSchema.js');
const bearerAuth = require('./middleware/bearer-auth.js');
const app = express();

const sequelize = new Sequelize('sqlite:memory');
const UserModel = userSchema(sequelize, DataTypes);

// app level middleware
app.use(express.json());
app.use(morgan('tiny')); // third party logger
app.use(cors());

app.post('/signup', (req, res) => {

    let {username, password } = req.body;

    let user = UserModel.create({username, password});

    res.status(201).send({
        user: {id: user.id, username: user.username},
        token: user.token,
    })
});

app.get('/posts', bearerAuth(UserModel), acl('read'), (req,res) => {
    console.log('you made it!');
    res.status(200).send('Incoming posts.');
});

sequelize.sync()
.then(()=> {
    app.list(3000)
})
```